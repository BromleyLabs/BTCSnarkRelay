// @author Bon Filey <bon@bromleylabs.io>
// @author Anurag Gupta <anurag@bromleylabs.io>
// Copyright (c) Bromley Labs Inc.        

//COMPUTE_NEW_TARGET
//@dev Compute new target value for the current block given previous blocks data
//@param prevTime Timestamp value in seconds of previous block 
//@param startTime Timestamp value in seconds of block where difficulty was adjusted
//@param prevTarget Target value computed from nbits of previous block

def main(prevTime, startTime, currTarget, prevTarget, flag):
    TARGETSPAN =  14 * 24 * 60 * 60  // 2 weeks 
    TARGETSPANDIV4 =  TARGETSPAN / 4
    TARGETSPANMUL4 =  TARGETSPAN * 4
    UNROUNDEDMAXTARGET = 2**224 - 1 

    actualSpan = prevTime - startTime
    // TODO: temporarily commented out
    //atualspan = if actualSpan < TARGETSPANDIV4 then TARGETSPANDIV4 else actualSpan fi 
    //atualspan = if TARGETSPANMUL4 < actualSpan then TARGETSPANMUL4 else actualSpan fi 
     
    // It can be verified that the mulitplications below will not exceed the
    // field limit

    //currTarget  = (actualSpan * prevTarget) / TARGETSPAN
    a = currTarget * TARGETSPAN * flag 
    b = actualSpan * prevTarget * flag 
    a == b 

    // TODO: Do we really need to check for the condition below?
    //currTarget = if UNROUNDEDMAXTARGET  < currTarget then UNROUNDEDMAXTARGET else currTarget fi 

    return 1
